-- Ticket #412
-- Create table document.document_chunk
CREATE TABLE document.document_chunk
(
   id character varying(40) NOT NULL DEFAULT uuid_generate_v1(), 
   document_id character varying(40) NOT NULL, 
   claim_id character varying(40), 
   start_position bigint NOT NULL, 
   size bigint NOT NULL, 
   body bytea NOT NULL, 
   md5 character varying(50), 
   creation_time timestamp without time zone NOT NULL DEFAULT now(), 
   user_name character varying(50) NOT NULL, 
   CONSTRAINT id_pkey_document_chunk PRIMARY KEY (id), 
   CONSTRAINT start_unique_document_chunk UNIQUE (document_id, start_position)
) 
WITH (
  OIDS = FALSE
)
;
COMMENT ON COLUMN document.document_chunk.id IS 'Unique ID of the chunk';
COMMENT ON COLUMN document.document_chunk.document_id IS 'Document ID, which will be used to create final document object. Used to group all chunks together.';
COMMENT ON COLUMN document.document_chunk.claim_id IS 'Claim ID. Used to clean the table when saving claim. It will guarantee that no orphan chunks left in the table.';
COMMENT ON COLUMN document.document_chunk.start_position IS 'Staring position of the byte in the source/destination document';
COMMENT ON COLUMN document.document_chunk.size IS 'Size of the chunk in bytes.';
COMMENT ON COLUMN document.document_chunk.body IS 'The content of the chunk.';
COMMENT ON COLUMN document.document_chunk.md5 IS 'Checksum of the chunk, calculated using MD5.';
COMMENT ON COLUMN document.document_chunk.creation_time IS 'Date and time when chuck was created.';
COMMENT ON COLUMN document.document_chunk.user_name IS 'User''s id (name), who has loaded the chunk';
COMMENT ON TABLE document.document_chunk
  IS 'Holds temporary pieces of a document uploaded on the server. In case of large files, document can be split into smaller pieces (chunks) allowing reliable upload. After all pieces uploaded, client will instruct server to create a document and remove temporary files stored in this table.';
  
-- Create OpenTenure schema
CREATE SCHEMA opentenure;
COMMENT ON SCHEMA opentenure
  IS 'This schema holds objects purely related to OpenTenure feature of SOLA';

-- Sequence: opentenure.opentenure_nr_seq

CREATE SEQUENCE opentenure.claim_nr_seq
  INCREMENT 1
  MINVALUE 1
  MAXVALUE 9999
  START 1
  CACHE 1
  CYCLE;
ALTER TABLE opentenure.claim_nr_seq
  OWNER TO postgres;
COMMENT ON SEQUENCE opentenure.claim_nr_seq
  IS 'Sequence number used as the basis for the claim nr field. This sequence is used by the generate-claim-nr business rule.';

-- Insert BR rule to generate claim number
insert into system.br (id, display_name, technical_type_code, feedback, description, technical_description) values 
('generate-claim-nr', 'generate-claim-nr', 'sql', '', '', '');

insert into system.br_definition (br_id, active_from, active_until, body) values 
('generate-claim-nr', '2014-02-20', 'infinity', 
'SELECT coalesce(system.get_setting(''system-id''), '''') || to_char(now(), ''yymm'') || trim(to_char(nextval(''opentenure.claim_nr_seq''), ''0000'')) AS vl');

-- Create claim_status table 
CREATE TABLE opentenure.claim_status
(
  code character varying(20) NOT NULL, -- The code for the claim status.
  display_value character varying(500) NOT NULL, -- Displayed value of the claim status.
  status character(1) NOT NULL DEFAULT 't'::bpchar, -- Status of the service status type
  description character varying(1000), -- Description of the claim status.
  CONSTRAINT claim_status_pkey PRIMARY KEY (code),
  CONSTRAINT claim_status_display_value_unique UNIQUE (display_value)
)
WITH (
  OIDS=FALSE
);
ALTER TABLE opentenure.claim_status
  OWNER TO postgres;
COMMENT ON TABLE opentenure.claim_status
  IS 'Code list of claim status.';
COMMENT ON COLUMN opentenure.claim_status.code IS 'The code for the claim status.';
COMMENT ON COLUMN opentenure.claim_status.display_value IS 'Displayed value of the claim status.';
COMMENT ON COLUMN opentenure.claim_status.status IS 'Status of the service claim.';
COMMENT ON COLUMN opentenure.claim_status.description IS 'Description of the claim status.';

-- Insert claim status
insert into opentenure.claim_status (code, display_value, status, description) values 
('unmoderated', 'Un-moderated', 'i', '');

insert into opentenure.claim_status (code, display_value, status, description) values 
('challenged', 'Challenged', 'i', '');

insert into opentenure.claim_status (code, display_value, status, description) values 
('moderated', 'Moderated', 'i', '');

-- Create claim table
CREATE TABLE opentenure.claim
(
  id character varying(40) NOT NULL, -- Identifier for the claim.
  nr character varying(15) NOT NULL, -- Auto generated claim number. Generated by the generate-claim-nr business rule when the claim record is initially saved.
  lodgement_date timestamp without time zone NOT NULL DEFAULT now(), -- The lodgement date and time of the claim. 
  challenge_expiry_date timestamp without time zone NOT NULL, -- Expiration date when challenge claim can be submitted. 
  decision_date timestamp without time zone, -- The decision date on the claim by the authority
  description character varying(250), -- Free description of the claim.
  challenged_claim_id character varying(40), -- The identifier of the challenged claim. If this value is provided, it means the record is a claim challenge type.
  claimant_id character varying(40) NOT NULL, -- The identifier of the claimant.
  mapped_geometry geometry, -- Claimed property geometry calculated using system SRID
  gps_geometry geometry, -- Claimed property geometry in Lat/Long format 
  status_code character varying(20) NOT NULL DEFAULT 'lodged'::character varying, -- The status of the claim.
  recorder_name character varying(50) NOT NULL, -- User's ID, who has created the claim.
  rowidentifier character varying(40) NOT NULL DEFAULT uuid_generate_v1(), -- Identifies the all change records for the row in the claim_historic table
  rowversion integer NOT NULL DEFAULT 0, -- Sequential value indicating the number of times this row has been modified.
  change_action character(1) NOT NULL DEFAULT 'i'::bpchar, -- Indicates if the last data modification action that occurred to the row was insert (i), update (u) or delete (d).
  change_user character varying(50), -- The user id of the last person to modify the row.
  change_time timestamp without time zone NOT NULL DEFAULT now(), -- The date and time the row was last modified.

  CONSTRAINT claim_pkey PRIMARY KEY (id ),
  CONSTRAINT claim_claimant_id_fk8 FOREIGN KEY (claimant_id)
      REFERENCES party.party (id) MATCH SIMPLE
      ON UPDATE CASCADE ON DELETE RESTRICT,
  CONSTRAINT claim_status_code_fk18 FOREIGN KEY (status_code)
      REFERENCES opentenure.claim_status (code) MATCH SIMPLE
      ON UPDATE CASCADE ON DELETE RESTRICT,
  CONSTRAINT enforce_geotype_mapped_geometry CHECK (geometrytype(mapped_geometry) = 'POLYGON'::text OR mapped_geometry IS NULL),
  CONSTRAINT enforce_geotype_gps_geometry CHECK (geometrytype(gps_geometry) = 'POLYGON'::text OR gps_geometry IS NULL),
  CONSTRAINT enforce_srid_mapped_geometry CHECK (st_srid(mapped_geometry) = 2193),
  CONSTRAINT enforce_valid_mapped_geometry CHECK (st_isvalid(mapped_geometry)),
  CONSTRAINT enforce_valid_gps_geometry CHECK (st_isvalid(gps_geometry))
)
WITH (
  OIDS=FALSE
);
ALTER TABLE opentenure.claim
  OWNER TO postgres;
COMMENT ON TABLE opentenure.claim
  IS 'Main table to store claim and claim challenge information submitted by the community recorders. SOLA Open Tenure extention.';
COMMENT ON COLUMN opentenure.claim.id IS 'Identifier for the claim.';
COMMENT ON COLUMN opentenure.claim.nr IS 'Auto generated claim number. Generated by the generate-claim-nr business rule when the claim record is initially saved.';
COMMENT ON COLUMN opentenure.claim.lodgement_date IS 'The lodgement date and time of the claim.';
COMMENT ON COLUMN opentenure.claim.challenge_expiry_date IS 'Expiration date when challenge claim can be submitted.';
COMMENT ON COLUMN opentenure.claim.decision_date IS 'The decision date on the claim by the authority.';
COMMENT ON COLUMN opentenure.claim.description IS 'Free description of the claim.';
COMMENT ON COLUMN opentenure.claim.challenged_claim_id IS 'The identifier of the challenged claim. If this value is provided, it means the record is a claim challenge type.';
COMMENT ON COLUMN opentenure.claim.claimant_id IS 'The identifier of the claimant.';
COMMENT ON COLUMN opentenure.claim.mapped_geometry IS 'Claimed property geometry calculated using system SRID';
COMMENT ON COLUMN opentenure.claim.gps_geometry IS 'Claimed property geometry in Lat/Long format';
COMMENT ON COLUMN opentenure.claim.status_code IS 'The status of the claim.';
COMMENT ON COLUMN opentenure.claim.recorder_name IS 'User''s ID, who has created the claim.';
COMMENT ON COLUMN opentenure.claim.rowidentifier IS 'Identifies the all change records for the row in the claim_historic table.';
COMMENT ON COLUMN opentenure.claim.rowversion IS 'Sequential value indicating the number of times this row has been modified.';
COMMENT ON COLUMN opentenure.claim.change_action IS 'Indicates if the last data modification action that occurred to the row was insert (i), update (u) or delete (d).';
COMMENT ON COLUMN opentenure.claim.change_user IS 'The user id of the last person to modify the row.';
COMMENT ON COLUMN opentenure.claim.change_time IS 'The date and time the row was last modified.';

CREATE TRIGGER __track_changes
  BEFORE INSERT OR UPDATE
  ON opentenure.claim
  FOR EACH ROW
  EXECUTE PROCEDURE f_for_trg_track_changes();

CREATE TRIGGER __track_history
  AFTER UPDATE OR DELETE
  ON opentenure.claim
  FOR EACH ROW
  EXECUTE PROCEDURE f_for_trg_track_history();
    
-- Create historic claim table
CREATE TABLE opentenure.claim_historic
(
  id character varying(40),
  nr character varying(15),
  lodgement_date timestamp without time zone,
  challenge_expiry_date timestamp without time zone,
  decision_date timestamp without time zone,
  description character varying(250),
  challenged_claim_id character varying(40),
  claimant_id character varying(40) NOT NULL,
  mapped_geometry geometry,
  gps_geometry geometry,
  status_code character varying(20),
  recorder_name character varying(50), 
  rowidentifier character varying(40),
  rowversion integer,
  change_action character(1),
  change_user character varying(50),
  change_time timestamp without time zone,
  change_time_valid_until timestamp without time zone NOT NULL DEFAULT now()
)
WITH (
  OIDS=FALSE
);

ALTER TABLE opentenure.claim_historic
  OWNER TO postgres;
COMMENT ON TABLE opentenure.claim_historic
  IS 'Historic table for the main table with claims opentenure.claim. Keeps all changes done to the main table.';

-- Craete claim_uses_source table

CREATE TABLE opentenure.claim_uses_source
(
  claim_id character varying(40) NOT NULL, -- Identifier for the calim the record is associated to.
  source_id character varying(40) NOT NULL, -- Identifier of the source associated to the claim.
  rowidentifier character varying(40) NOT NULL DEFAULT uuid_generate_v1(), -- Unique row identifier.
  rowversion integer NOT NULL DEFAULT 0, -- Sequential value indicating the number of times this row has been modified.
  change_action character(1) NOT NULL DEFAULT 'i'::bpchar, -- Indicates if the last data modification action that occurred to the row was insert (i), update (u) or delete (d).
  change_user character varying(50), -- The user id of the last person to modify the row.
  change_time timestamp without time zone NOT NULL DEFAULT now(), -- The date and time the row was last modified.
  CONSTRAINT claim_uses_source_pkey PRIMARY KEY (claim_id, source_id ),
  CONSTRAINT claim_uses_source_claim_id_fk126 FOREIGN KEY (claim_id)
      REFERENCES opentenure.claim (id) MATCH SIMPLE
      ON UPDATE CASCADE ON DELETE CASCADE,
  CONSTRAINT claim_uses_source_source_id_fk127 FOREIGN KEY (source_id)
      REFERENCES source.source (id) MATCH SIMPLE
      ON UPDATE CASCADE ON DELETE CASCADE
)
WITH (
  OIDS=FALSE
);
ALTER TABLE opentenure.claim_uses_source
  OWNER TO postgres;
COMMENT ON TABLE opentenure.claim_uses_source
  IS 'Links the claim to the sources (a.k.a. documents) submitted with the claim. SOLA Open Tenure extension.';
COMMENT ON COLUMN opentenure.claim_uses_source.claim_id IS 'Identifier for the claim the record is associated to.';
COMMENT ON COLUMN opentenure.claim_uses_source.source_id IS 'Identifier of the source associated to the claim.';
COMMENT ON COLUMN opentenure.claim_uses_source.rowidentifier IS 'Unique row identifier.';
COMMENT ON COLUMN opentenure.claim_uses_source.rowversion IS 'Sequential value indicating the number of times this row has been modified.';
COMMENT ON COLUMN opentenure.claim_uses_source.change_action IS 'Indicates if the last data modification action that occurred to the row was insert (i), update (u) or delete (d).';
COMMENT ON COLUMN opentenure.claim_uses_source.change_user IS 'The user id of the last person to modify the row.';
COMMENT ON COLUMN opentenure.claim_uses_source.change_time IS 'The date and time the row was last modified.';

CREATE TRIGGER __track_changes
  BEFORE INSERT OR UPDATE
  ON opentenure.claim_uses_source
  FOR EACH ROW
  EXECUTE PROCEDURE f_for_trg_track_changes();

CREATE TRIGGER __track_history
  AFTER UPDATE OR DELETE
  ON opentenure.claim_uses_source
  FOR EACH ROW
  EXECUTE PROCEDURE f_for_trg_track_history();

-- Craete claim_uses_source_historic table

CREATE TABLE opentenure.claim_uses_source_historic
(
  claim_id character varying(40),
  source_id character varying(40),
  rowidentifier character varying(40),
  rowversion integer NOT NULL,
  change_action character(1),
  change_user character varying(50),
  change_time timestamp without time zone,
  change_time_valid_until timestamp without time zone NOT NULL DEFAULT now()
)
WITH (
  OIDS=FALSE
);
ALTER TABLE opentenure.claim_uses_source_historic
  OWNER TO postgres;
COMMENT ON TABLE opentenure.claim_uses_source_historic
  IS 'Historic table for opentenure.claim_uses_source. Keeps all changes done to the main table.';

-- Make changes to party table to add birthday column
--- DROP DEPENDENT OBJECTS -----
DROP VIEW administrative.sys_reg_state_land;

ALTER TABLE administrative.ba_unit_as_party 
 DROP CONSTRAINT ba_unit_as_party_party_id_fk72;
 
ALTER TABLE administrative.party_for_rrr
DROP CONSTRAINT party_for_rrr_party_id_fk82;

ALTER TABLE application.application
DROP CONSTRAINT application_agent_id_fk8;

ALTER TABLE application.application
DROP CONSTRAINT application_contact_person_id_fk14;

ALTER TABLE party.group_party
DROP CONSTRAINT group_party_id_fk32;

ALTER TABLE party.party_role 	  
	  DROP CONSTRAINT party_role_party_id_fk36;
	  
ALTER TABLE party.party_member 
	  DROP CONSTRAINT party_member_party_id_fk34;

ALTER TABLE opentenure.claim 
	  DROP CONSTRAINT claim_claimant_id_fk8;

ALTER TABLE party.party DISABLE TRIGGER USER;

ALTER TABLE party.party ADD COLUMN birth_date date,
ADD COLUMN rowidentifier1 character varying(40) NOT NULL DEFAULT uuid_generate_v1(),
ADD COLUMN rowversion1 integer NOT NULL DEFAULT 0,
ADD COLUMN change_action1 character(1) NOT NULL DEFAULT 'i'::bpchar,
ADD COLUMN change_user1 character varying(50),
ADD COLUMN change_time1 timestamp without time zone NOT NULL DEFAULT now();

DROP INDEX party.party_index_on_rowidentifier;

UPDATE party.party SET rowidentifier1 = rowidentifier, rowversion1 = rowversion, 
change_action1 = change_action, change_user1 = change_user, change_time1 = change_time;

ALTER TABLE party.party DROP COLUMN rowidentifier,
DROP COLUMN rowversion, DROP COLUMN change_action, DROP COLUMN change_user, DROP COLUMN change_time; 

ALTER TABLE party.party RENAME COLUMN rowidentifier1 TO rowidentifier;
ALTER TABLE party.party RENAME COLUMN rowversion1 TO rowversion;
ALTER TABLE party.party RENAME COLUMN change_action1 TO change_action;
ALTER TABLE party.party RENAME COLUMN change_user1 TO change_user;
ALTER TABLE party.party RENAME COLUMN change_time1 TO change_time;

--- ADD COMMENTS ----
COMMENT ON COLUMN party.party.birth_date IS 'SOLA Extension: Date of birth.';
COMMENT ON COLUMN party.party.rowidentifier IS 'SOLA Extension: Identifies the all change records for the row in the party_historic table';
COMMENT ON COLUMN party.party.rowversion IS 'SOLA Extension: Sequential value indicating the number of times this row has been modified.';
COMMENT ON COLUMN party.party.change_action IS 'SOLA Extension: Indicates if the last data modification action that occurred to the row was insert (i), update (u) or delete (d).';
COMMENT ON COLUMN party.party.change_user IS 'SOLA Extension: The user id of the last person to modify the row.';
COMMENT ON COLUMN party.party.change_time IS 'SOLA Extension: The date and time the row was last modified.';

CREATE INDEX party_index_on_rowidentifier
  ON party.party
  USING btree
  (rowidentifier COLLATE pg_catalog."default" );

--- HISTORIC TABLE -----
ALTER TABLE party.party_historic ADD COLUMN birth_date date,
ADD COLUMN rowidentifier1 character varying(40) NOT NULL DEFAULT uuid_generate_v1(),
ADD COLUMN rowversion1 integer NOT NULL DEFAULT 0,
ADD COLUMN change_action1 character(1) NOT NULL DEFAULT 'i'::bpchar,
ADD COLUMN change_user1 character varying(50),
ADD COLUMN change_time1 timestamp without time zone NOT NULL DEFAULT now(),
ADD COLUMN change_time_valid_until1 timestamp without time zone NOT NULL DEFAULT now();

DROP INDEX party.party_historic_index_on_rowidentifier;
  
UPDATE party.party_historic SET rowidentifier1 = rowidentifier, rowversion1 = rowversion, change_action1 = change_action, 
change_user1 = change_user, change_time1 = change_time, change_time_valid_until1 = change_time_valid_until;

ALTER TABLE party.party_historic DROP COLUMN rowidentifier, DROP COLUMN rowversion, DROP COLUMN change_action, 
DROP COLUMN change_user, DROP COLUMN change_time, DROP COLUMN change_time_valid_until; 

ALTER TABLE party.party_historic RENAME COLUMN rowidentifier1 TO rowidentifier;
ALTER TABLE party.party_historic RENAME COLUMN rowversion1 TO rowversion;
ALTER TABLE party.party_historic RENAME COLUMN change_action1 TO change_action;
ALTER TABLE party.party_historic RENAME COLUMN change_user1 TO change_user;
ALTER TABLE party.party_historic RENAME COLUMN change_time1 TO change_time;
ALTER TABLE party.party_historic RENAME COLUMN change_time_valid_until1 TO change_time_valid_until;

CREATE INDEX party_historic_index_on_rowidentifier
  ON party.party_historic
  USING btree
  (rowidentifier COLLATE pg_catalog."default" );

---- ENABLE TRIGGERS -----
ALTER TABLE party.party ENABLE TRIGGER USER;
  
--- CREATE DROPPED DEPENDENCY OBJECTS ----
CREATE OR REPLACE VIEW administrative.sys_reg_state_land AS 
 SELECT (pp.name::text || ' '::text) || COALESCE(pp.last_name, ' '::character varying)::text AS value, co.id, co.name_firstpart, co.name_lastpart, get_translation(lu.display_value, NULL::character varying) AS land_use_code, su.ba_unit_id, sa.size, 
        CASE
            WHEN COALESCE(co.land_use_code, 'residential'::character varying)::text = 'residential'::text THEN sa.size
            ELSE 0::numeric
        END AS residential, 
        CASE
            WHEN COALESCE(co.land_use_code, 'residential'::character varying)::text = 'agricultural'::text THEN sa.size
            ELSE 0::numeric
        END AS agricultural, 
        CASE
            WHEN COALESCE(co.land_use_code, 'residential'::character varying)::text = 'commercial'::text THEN sa.size
            ELSE 0::numeric
        END AS commercial, 
        CASE
            WHEN COALESCE(co.land_use_code, 'residential'::character varying)::text = 'industrial'::text THEN sa.size
            ELSE 0::numeric
        END AS industrial
   FROM cadastre.land_use_type lu, cadastre.cadastre_object co, cadastre.spatial_value_area sa, administrative.ba_unit_contains_spatial_unit su, application.application aa, application.service s, party.party pp, administrative.party_for_rrr pr, administrative.rrr rrr, administrative.ba_unit bu, transaction.transaction t
  WHERE sa.spatial_unit_id::text = co.id::text AND COALESCE(co.land_use_code, 'residential'::character varying)::text = lu.code::text AND sa.type_code::text = 'officialArea'::text AND su.spatial_unit_id::text = sa.spatial_unit_id::text AND bu.transaction_id::text = t.id::text AND t.from_service_id::text = s.id::text AND s.application_id::text = aa.id::text AND s.request_type_code::text = 'systematicRegn'::text AND s.status_code::text = 'completed'::text AND pp.id::text = pr.party_id::text AND pr.rrr_id::text = rrr.id::text AND rrr.ba_unit_id::text = su.ba_unit_id::text AND rrr.type_code::text = 'stateOwnership'::text AND bu.id::text = su.ba_unit_id::text
  ORDER BY (pp.name::text || ' '::text) || COALESCE(pp.last_name, ' '::character varying)::text;

ALTER TABLE administrative.sys_reg_state_land
  OWNER TO postgres;
COMMENT ON VIEW administrative.sys_reg_state_land
  IS 'Used by systematic registration to identify state land under SR.';
 
 ALTER TABLE administrative.ba_unit_as_party 
	  ADD CONSTRAINT ba_unit_as_party_party_id_fk72 FOREIGN KEY (party_id)
      REFERENCES party.party (id) MATCH SIMPLE
      ON UPDATE CASCADE ON DELETE CASCADE;
	  
ALTER TABLE administrative.party_for_rrr
	  ADD CONSTRAINT party_for_rrr_party_id_fk82 FOREIGN KEY (party_id)
      REFERENCES party.party (id) MATCH SIMPLE
      ON UPDATE CASCADE ON DELETE CASCADE;
	  
ALTER TABLE application.application
	  ADD CONSTRAINT application_agent_id_fk8 FOREIGN KEY (agent_id)
      REFERENCES party.party (id) MATCH SIMPLE
      ON UPDATE CASCADE ON DELETE RESTRICT;
	  
ALTER TABLE application.application	  
	  ADD CONSTRAINT application_contact_person_id_fk14 FOREIGN KEY (contact_person_id)
      REFERENCES party.party (id) MATCH SIMPLE
      ON UPDATE CASCADE ON DELETE RESTRICT;
	  
ALTER TABLE party.group_party  
	  ADD CONSTRAINT group_party_id_fk32 FOREIGN KEY (id)
      REFERENCES party.party (id) MATCH SIMPLE
      ON UPDATE CASCADE ON DELETE CASCADE;
	  
ALTER TABLE party.party_member 
	  ADD CONSTRAINT party_member_party_id_fk34 FOREIGN KEY (party_id)
      REFERENCES party.party (id) MATCH SIMPLE
      ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE party.party_role 	  
	  ADD CONSTRAINT party_role_party_id_fk36 FOREIGN KEY (party_id)
      REFERENCES party.party (id) MATCH SIMPLE
      ON UPDATE CASCADE ON DELETE CASCADE;

ALTER TABLE opentenure.claim 
	  ADD CONSTRAINT claim_claimant_id_fk8 FOREIGN KEY (claimant_id)
      REFERENCES party.party (id) MATCH SIMPLE
      ON UPDATE CASCADE ON DELETE RESTRICT;
	 
-- ADD MIME TYPE FIELD TO DOCUMENT TABLE
DROP INDEX document.document_index_on_rowidentifier;

ALTER TABLE document.document DISABLE TRIGGER USER;

ALTER TABLE document.document ADD COLUMN mime_type character varying(20),
ADD COLUMN body1 bytea NOT NULL,
ADD COLUMN description1 character varying(100),
ADD COLUMN rowidentifier1 character varying(40) NOT NULL DEFAULT uuid_generate_v1(),
ADD COLUMN rowversion1 integer NOT NULL DEFAULT 0,
ADD COLUMN change_action1 character(1) NOT NULL DEFAULT 'i'::bpchar,
ADD COLUMN change_user1 character varying(50),
ADD COLUMN change_time1 timestamp without time zone NOT NULL DEFAULT now();

UPDATE document.document SET body1 = body, description1 = description, rowidentifier1 = rowidentifier, rowversion1 = rowversion, 
change_action1 = change_action, change_user1 = change_user, change_time1 = change_time;

ALTER TABLE document.document DROP COLUMN body, DROP COLUMN description, DROP COLUMN rowidentifier,
DROP COLUMN rowversion, DROP COLUMN change_action, DROP COLUMN change_user, DROP COLUMN change_time; 

ALTER TABLE document.document RENAME COLUMN body1 TO body;
ALTER TABLE document.document RENAME COLUMN description1 TO description;
ALTER TABLE document.document RENAME COLUMN rowidentifier1 TO rowidentifier;
ALTER TABLE document.document RENAME COLUMN rowversion1 TO rowversion;
ALTER TABLE document.document RENAME COLUMN change_action1 TO change_action;
ALTER TABLE document.document RENAME COLUMN change_user1 TO change_user;
ALTER TABLE document.document RENAME COLUMN change_time1 TO change_time;

ALTER TABLE document.document ENABLE TRIGGER USER;

COMMENT ON COLUMN document.document.body IS 'The content of the electronic file.';
COMMENT ON COLUMN document.document.description IS 'A descriptive name to help recognize the file such as the original file name.';
COMMENT ON COLUMN document.document.rowidentifier IS 'Identifies the all change records for the row in the document_historic table';
COMMENT ON COLUMN document.document.rowversion IS 'Sequential value indicating the number of times this row has been modified.';
COMMENT ON COLUMN document.document.change_action IS 'Indicates if the last data modification action that occurred to the row was insert (i), update (u) or delete (d).';
COMMENT ON COLUMN document.document.change_user IS 'The user id of the last person to modify the row.';
COMMENT ON COLUMN document.document.change_time IS 'The date and time the row was last modified.';

CREATE INDEX document_index_on_rowidentifier
  ON document.document
  USING btree
  (rowidentifier COLLATE pg_catalog."default" );

-- ADD MIME TYPE FIELD TO DOCUMENT_HISTORIC TABLE
DROP INDEX document.document_historic_index_on_rowidentifier;

ALTER TABLE document.document_historic ADD COLUMN mime_type character varying(20),
ADD COLUMN body1 bytea,
ADD COLUMN description1 character varying(100),
ADD COLUMN rowidentifier1 character varying(40),
ADD COLUMN rowversion1 integer NOT NULL DEFAULT 0,
ADD COLUMN change_action1 character(1),
ADD COLUMN change_user1 character varying(50),
ADD COLUMN change_time1 timestamp without time zone,
ADD COLUMN change_time_valid_until1 timestamp without time zone NOT NULL DEFAULT now();

UPDATE document.document_historic SET body1 = body, description1 = description, rowidentifier1 = rowidentifier, rowversion1 = rowversion, 
change_action1 = change_action, change_user1 = change_user, change_time1 = change_time, change_time_valid_until1 = change_time_valid_until;

ALTER TABLE document.document_historic DROP COLUMN body, DROP COLUMN description, DROP COLUMN rowidentifier,
DROP COLUMN rowversion, DROP COLUMN change_action, DROP COLUMN change_user, DROP COLUMN change_time, DROP COLUMN change_time_valid_until; 

ALTER TABLE document.document_historic RENAME COLUMN body1 TO body;
ALTER TABLE document.document_historic RENAME COLUMN description1 TO description;
ALTER TABLE document.document_historic RENAME COLUMN rowidentifier1 TO rowidentifier;
ALTER TABLE document.document_historic RENAME COLUMN rowversion1 TO rowversion;
ALTER TABLE document.document_historic RENAME COLUMN change_action1 TO change_action;
ALTER TABLE document.document_historic RENAME COLUMN change_user1 TO change_user;
ALTER TABLE document.document_historic RENAME COLUMN change_time1 TO change_time;
ALTER TABLE document.document_historic RENAME COLUMN change_time_valid_until1 TO change_time_valid_until;

CREATE INDEX document_historic_index_on_rowidentifier
  ON document.document_historic
  USING btree
  (rowidentifier COLLATE pg_catalog."default" );
  
INSERT INTO system.version SELECT '1404a' WHERE NOT EXISTS (SELECT version_num FROM system.version WHERE version_num = '1404a');
